package nafmaxia;

import java.util.Scanner;
import java.util.Random;

public class MiniNafmaxia {
	
	static int[][] board = new int[5][5];   
	static int[][] ships;              
	static int shipsdown = 0;      
	
	static void initboard() {        
		for (int i = 0; i < 5; i++) {
			for (int j = 0; j < 5; j++)
				board[i][j] = -1;
	}
   }
	 
	static void initships() {     // Φτιάχνουμε μία μέθοδο για τα κρυμμένα πλοία (που σε ατή την φάση θα πρέπει να ξέρουμε που βρίσκεται το κάθε πλοίο για λόγους testing).
		ships = new int[][]{ {-1, -1}, {-1, -1}, {-1, -1} }; 	// Στην αρχή θέλω να τοποθετήσω τα 3 πλοία εκτός ταμπλό (βάζοντας σε όλα τα πλοία -1) για πιο δίκαιη τοποθέτηση. Μπορώ να βάλω ότι πρόκειται για έναν πίνακα 3Χ2 χωρίς να δώσω τα στοιχεία (-1 δηλαδή για 6 φορές).
		Random generatorRandom = new Random();	// Παράγω ένα ζεύγος ακεραίων όπου για 3 φορές αυτό το τυχαίο ζεύγος πηγαίνω και το βάζω στον αντίστοιχο εσωτερικό πίνακα.
		int row; int col; 	// Δηλώνω/δημιουργώ 2 μεταβλητές ακέραιου τύπου έξω από την for.
		for (int i = 0; i < 3; i++) {	// Φτιάχνω μία επαναληπτική δομή for που αρχικοποιώ την i = 0, μικρότερη του 3 και με βήμα 1 να κάνει τα εξής.
			do {				// Βάζω την παραγωγή της τυχαίας θέσης μέσα στην επαναληπτική δομή do while (φτιάχνε μου τυχαίες θέσεις όσο υπάρχει πλοίο σε αυτές τις θέσεις row, col.
			row = generatorRandom.nextInt(5);  // Οι συντεταγμένες εδώ βασίζονται στο σύστημα συντεταγμένων της java κι όχι στου χρήστη. Μέσα στην for εκχωρώ και αποθηκεύω στην μεταβλητή row έναν τυχαίο ακέραιο αριθμό (για την γραμμή στην οποία θα τοποθετηθεί τυχαία το πλοίο) μέσω χρήσης του αντικειμένου random. Βάζω άνω όριο και για αυτό μέσα στην παρένθεση του random ορίζω ως άνω όριο το 5 που σημαίνει ότι ο τυχαίος ακέραιος που θα παραχθεί θα είναι μεταξύ 0 και 4 αφού το 5 δεν θα συμπεριληφθεί όπως το έχω ορίσει μέσα στην παρένθεση.
			col = generatorRandom.nextInt(5);  // Μέσα στην for εκχωρώ και αποθηκεύω στην μεταβλητή col έναν τυχαίο ακέραιο αριθμό (για την στήλη στην οποία θα τοποθετηθεί τυχαία το πλοίο) μέσω χρήσης του αντικειμένου random.
			}	while (shipison(row, col));	// Θα πρέπει να ελέγξω εάν σε αυτή την θέση υπάρχει πλοίο ή όχι. Εάν δεν υπάρχει άλλο πλοίο σε αυτή την θέση και μού δώσει false η συνθήκη τότε γίνεται η τοποθέτηση του πλοίου στο ταμπλό. Εάν η συνθήκη while μού δώσει αποτέλσμα true τότε θέλω να παράξω ξανά τυχαίους ακέραιους αριθμούς. Καλώ στην συνθήκη την μέθοδο shipison (η οποία απλά κοιτάζει αν υπάρχει πλοίο σε κάποια δοθείσα θέση κάνοντας έναν καθαρό υπολογισμό χωρίς να πειράζει τα πράγματα στο παιχνίδι καθώς παίρνει 1 στόχο και μού επιστρέφει αληθοτιμή εάν δηλαδή υπάρχει πλοίο σε αυτό τον στόχο.
			ships[i][0] = row;	// Στην πρώτη επανάληψη η συνθήκη αποκλείεται να μού δώσει true αφού όλα τα πλοία είναι εκτός ταμπλό και άρα θα γίνει η τοποθέτηση του 1ου πλοίου. Στην δεύετρη επανάληψη υπάρχει μια μικρή πιθανότητα να υπάρχει το πρώτο πλοίο που τοποθετήσαμε στην ίδια τυχαία θέση. Για το i οστο πλοίο (όπου στην πρώτη επανάληψη το ships θα είναι 0 και θα είναι το 1ο στοιχείο του πίνακα ships (το πρώτο ζεύγος δηλαδή-γραμμή, στήλη). Αυτό σημαίνει ότι στην θέση 0 βάλε τον τυχαίο ακέραιο για το row και στην θέση 1 βάλε τον τυχαίο ακέραιο για το col. Αφού πρόκειται για εξωτερικό μονοδιάστατο πίνακα όπου το κάθε στοιχείο του (γραμμή, στήλη) είναι μονοδιάσττος πίνακας.
			ships[i][1] = col;	
		}
	}
	
	 static void printhint(int tRow, int tCol) { 
		 int countR = 0; int countC = 0;   
		 for (int[] ship : ships) {    
			 if (ship[0] == tRow)  
				 countR++;        
			 if (ship[1] == tCol)  
				 countC++;		  
		 }
		 	System.out.printf("Row %d has %d ships. Column %d has %d ships.\n", tRow+1, countR, tCol+1, countC);   
	 }
	
	static void printboard() {      
			System.out.println("  1 2 3 4 5");  
		for (int i = 0; i < 5; i++) {      
		System.out.print(i+1);             
			for (int j = 0; j < 5; j++)   
				switch (board[i][j]) {     
				case 1 -> { System.out.print(" X"); }   
				case 0 -> { System.out.print(" *"); }   
				default -> { System.out.print(" ~"); }  
				}
		 System.out.println();             
	  }
	 }
	
	static boolean shipison(int tRow, int tCol) {  
		for (int[] ship : ships) {  // Δημιουργούμαι μία μεταβλητή ship η οποία θα διατρέξει ένα-ένα τα πλοία που έχουμε μέσα στον πίνακα ships-με το κάθε ζεύγος που βρίσκω μέσα στον πίνακα ships-(δισδιάστατος πίνακας όπου κάθε στοιχείο του είναι πίνακας), για αυτό και ο τύπος του είναι μονοδιάστατος διθέσιος πίνακας.
			if (ship[0] == tRow && ship[1] == tCol)  // Ελέγχεται και θέλουμε να ισχύουν 2 συνθήκες ταυτόχρονα μέσω του λογικού τελεστή && εάν το πρώτο στοιχείο του πίνακα ship ισούται με το tRow κι εάν το δεύτερο στοιχείο του πίνακα ισούται με το tCol.
				return true;   // Εάν ναι (μέσω της εντολής return διακόπτεται η εκτέλεση της μεθόδου) και σημαίνει ότι ο παίκτης πέτυχε πλοίο και δεν ψάχνει τα επόμενα πλοία και μού επιστρέφει την τιμή true.
		}
			return false;  // Εάν όχι (μέσω της εντολής return διακόπτεται η εκτέλεση της μεθόδου) επιστρέφει false, μόνο όταν έχουμε διατρέξει όλο τον πίνακα και δεν έχουμε βρεί πλοίο που να βρίσκεται στην ίδια θέση με τον στόχο. Το return false θα εκτελεστεί μόνο εάν δεν έχει εκτελεστεί νωρίτερα το return true, δηλαδή για κανένα ship να μην ισχύσει η παραπάνω συνθήκη.
	}
	
		static void shootandupdate(int tRow, int tCol) {    // Ως παράμετρο εισόδου βάζουμε τον στόχο που έχει επιλέξει ο χρήστης.
			if (shipison(tRow, tCol)) {  // Καλώ την μέθοδο shipison μέσω της μεθόδου shipison θέλουμε να ελέγξουμε εάν πετύχαμε πλοίο ή όχι. 
				board[tRow][tCol] = 1;   // Ενημέρωση του πίνακα board μέσω της βολής που έριξε ο χρήστης, όπου το tRow, tCol συμβολίζονται με τον ακέραιο 1 (ότι δηλαδή πετύχαμε πλοίο).
				shipsdown++;			 // Καθώς ο παίκτης ρίχνει τις βολές θέλουμε να μετράμε πόσα πλοία έχουν χτυπηθεί. Επομένως αυξάνουμε κατά 1 την μεταβλητή αυτή που συγκεντρώνει τον αριθμό των πλοίων που έχουν χτυπηθεί.
			System.out.println("A ship was hit!");  // Ενημέρωση του χρήστη ότι πέτυχε πλοίο.
				} else {
					board[tRow][tCol] = 0;  // Ενημέρωση του πίνακα board μέσω της βολής που έριξε ο χρήστης, όπου το tRow, tCol συμβολίζονται με τον ακέραιο 0 (ότι δηλαδή ο χρήστης αστόχησε).
					System.out.println("Shot missed..."); // Ενημέρωση του χρήστη ότι δεν πέτυχε πλοίο.
				 }
			printboard();  // Δείχνει το ταμπλό στον παίκτη αρχικά.
			printhint(tRow, tCol);    // Σε αυτή την μέθοδο (shootandupdate) θα γίνει η εκτέλεση της μεθόδου printhint που φτιάξαμε παραπάνω (με είσοδο τον υποτιθέμενο στόχο), γιατί κάθε φορά που ο χρήστης ρίχνει ένα στόχο θέλουμε να τον ενημερώνουμε για τον αριθμό των πλοίων που υπάρχουν στην ίδια γραμμή και στην ίδια στήλη. Στην προκειμένη περίπτωση το έχουμε βάλει έξω από την if else καθώς η μέθοδος printhint θα εκτελείται κάθε φορά που θα εκτελείται η μέθοδος shootandupdate και θα ενημερώνει κατάλληλα τον παίκτη.
		 }
		
	public static void main(String[] args) {
	// Αρχικοποίηση παιχνιδιού.
		initboard();       // Για την εκτέλεση της μεθόδου initboard που φτιάξαμε θα πρέπει να καλέσω την μέθοδο αυτή με το όνομά της κάτω στην μέθοδο main προκειμένου να εκτελεστεί.
		initships();       // Για την εκτέλεση της μεθόδου initships που φτιάξαμε θα πρέπει να καλέσω την μέθοδο αυτή με το όνομά της κάτω στην μέθοδο main προκειμένου να εκτελεστεί.
		printboard();      // Για την εκτέλεση της μεθόδου printboard που φτιάξαμε θα πρέπει να καλέσω την μέθοδο αυτή με το όνομά της κάτω στην μέθοδο main προκειμένου να εκτελεστεί.
		System.out.println("----------------"); // Απλά για να τα διαχωρίζει μεταξύ τους.
		
		// Είσοδος δεδομένων είναι 1 γύρος του παιχνιδιού όλο το παρακάτω. Επανάληψη ξανά και ξανά για να πέσουν όλα τα πλοία.
		while (shipsdown < 3) {
		Scanner scan = new Scanner(System.in);	// Φτιάχνω ένα αντικέιμενο scanner που διαβάζει είσοδο από την κονσόλα, δηλαδή λήψη εισόδου από τον χρήστη.
		int targetRow; int targetCol;
		do {
		System.out.print("Please enter the coordinate of the row: ");
		targetRow = scan.nextInt();  // Αναμένουμε 1 ακέραιο μεταξύ 1 και 5.
		System.out.print("Please enter the coordinate of the column: ");
		targetCol = scan.nextInt();		// Την στήλη που θέλει να ρίξει ο χρήστης
		} while(targetRow < 1 || targetCol > 5 || targetCol < 1 || targetCol > 5);
		shootandupdate(targetRow-1, targetCol-1);   // Εδώ δίνω εγώ τις συντεταγμένες καθώς δεν κάνει είσοδο ο χρήστης για λόγους testing που είπαμε. Ρίχνει βολή και κάνει update τον πίνακα.
		printboard();
		}
		System.out.println("Congratulations! You sank all the ships.");
 }
}
